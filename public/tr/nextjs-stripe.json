{
  "name": "nextjs-stripe",
  "description": "Stripe template for NextJS",
  "framework": "nextjs",
  "files": [
    {
      "target": "lib/stripe.ts",
      "type": "template",
      "content": "import Stripe from 'stripe'\n\nlet _stripe: Stripe | null = null\n\nexport const getStripe = (): Stripe => {\n  const key = process.env.STRIPE_SECRET_KEY\n  if (!key) {\n    throw new Error(\"STRIPE_SECRET_KEY is not set\")\n  }\n  if (!_stripe) {\n    _stripe = new Stripe(process.env.STRIPE_SECRET_KEY as string, {\n      \n    })\n  }\n  return _stripe\n}\n\nexport type Product = Stripe.Product\nexport type Customer = Stripe.Customer\nexport type Subscription = Stripe.Subscription\nexport type PaymentIntent = Stripe.PaymentIntent\n\nexport const getProducts = async ({ baseUrl }: { baseUrl?: string }): Promise<Product[]> => {\n  try {\n    const response = await fetch(`${baseUrl}/api/products`)\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch products: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error fetching products:', error)\n    throw error\n  }\n}\n\nexport const getProduct = async ({ baseUrl, product_id }: { baseUrl?: string, product_id: string }): Promise<Product> => {\n  try {\n    const response = await fetch(`${baseUrl}/api/product?product_id=${product_id}`)\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch product: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error fetching product:', error)\n    throw error\n  }\n}\n\nexport const getCustomer = async ({ baseUrl, customer_id }: { baseUrl?: string, customer_id: string }): Promise<Customer> => {\n  try {\n    const response = await fetch(`${baseUrl}/api/customer?customer_id=${customer_id}`)\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch customer: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error fetching customer:', error)\n    throw error\n  }\n}\n\nexport const getCustomerSubscriptions = async ({ baseUrl, customer_id }: { baseUrl?: string, customer_id: string }): Promise<Subscription[]> => {\n  try {\n    const response = await fetch(`${baseUrl}/api/customer/subscriptions?customer_id=${customer_id}`)\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch customer subscriptions: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error fetching customer subscriptions:', error)\n    throw error\n  }\n}\n\nexport const getCustomerPayments = async ({ baseUrl, customer_id }: { baseUrl?: string, customer_id: string }): Promise<PaymentIntent[]> => {\n  try {\n    const response = await fetch(`${baseUrl}/api/customer/payments?customer_id=${customer_id}`)\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch customer payments: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error fetching customer payments:', error)\n    throw error\n  }\n}\n\nexport const createCustomer = async ({ baseUrl, customer }: { baseUrl?: string, customer: Stripe.CustomerCreateParams }): Promise<Customer> => {\n  try {\n    const response = await fetch(`${baseUrl}/api/customer`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(customer),\n    })\n\n    if (!response.ok) {\n      throw new Error(`Failed to create customer: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error creating customer:', error)\n    throw error\n  }\n}\n\nexport const updateCustomer = async ({ baseUrl, customer_id, customer }: { baseUrl?: string, customer_id: string, customer: Stripe.CustomerUpdateParams }): Promise<Customer> => {\n  try {\n    const response = await fetch(`${baseUrl}/api/customer?customer_id=${customer_id}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(customer),\n    })\n\n    if (!response.ok) {\n      throw new Error(`Failed to update customer: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error updating customer:', error)\n    throw error\n  }\n}\n\nexport const checkout = async ({ \n  baseUrl, \n  productCart, \n  customer, \n  success_url, \n  cancel_url, \n  metadata \n}: { \n  baseUrl?: string, \n  productCart: Array<{ price_id: string; quantity: number }>, \n  customer?: { customer_id?: string; email?: string; name?: string; phone_number?: string }, \n  success_url: string, \n  cancel_url: string, \n  metadata?: Record<string, string> \n}) => {\n  try {\n    const response = await fetch(`${baseUrl}/api/checkout`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ productCart, customer, success_url, cancel_url, metadata }),\n    })\n\n    if (!response.ok) {\n      throw new Error(`Failed to checkout: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error checking out:', error)\n    throw error\n  }\n}"
    },
    {
      "target": "hooks/stripe/useBilling.ts",
      "type": "template",
      "content": "'use client'\n\nimport { useState, useCallback } from 'react'\nimport Stripe from 'stripe'\nimport {\n  getProducts,\n  getProduct,\n  getCustomer,\n  getCustomerSubscriptions,\n  getCustomerPayments,\n  createCustomer,\n  updateCustomer,\n  checkout,\n} from '@/lib/stripe'\n\ninterface UseBillingState {\n  loading: boolean\n  error: string | null\n}\n\nexport const useBilling = ({ baseUrl }: { baseUrl?: string }) => {\n  const [state, setState] = useState<UseBillingState>({\n    loading: false,\n    error: null,\n  })\n\n  const setLoading = useCallback((loading: boolean) => {\n    setState(prev => ({ ...prev, loading }))\n  }, [])\n\n  const setError = useCallback((error: string | null) => {\n    setState(prev => ({ ...prev, error }))\n  }, [])\n\n  const handleAsyncOperation = useCallback(async <T>(\n    operation: () => Promise<T>,\n    operationName: string\n  ): Promise<T> => {\n    try {\n      setLoading(true)\n      setError(null)\n      const result = await operation()\n      return result\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : `Failed to ${operationName}`\n      setError(errorMessage)\n      throw error\n    } finally {\n      setLoading(false)\n    }\n  }, [])\n\n  const fetchProducts = useCallback(async () => {\n    return handleAsyncOperation(() => getProducts({ baseUrl }), 'fetch products')\n  }, [handleAsyncOperation])\n\n  const fetchProduct = useCallback(async (product_id: string) => {\n    return handleAsyncOperation(() => getProduct({ baseUrl, product_id }), 'fetch product')\n  }, [handleAsyncOperation])\n\n  const fetchCustomer = useCallback(async (customer_id: string) => {\n    return handleAsyncOperation(() => getCustomer({ baseUrl, customer_id }), 'fetch customer')\n  }, [handleAsyncOperation])\n\n  const fetchCustomerSubscriptions = useCallback(async (customer_id: string) => {\n    return handleAsyncOperation(() => getCustomerSubscriptions({ baseUrl, customer_id }), 'fetch customer subscriptions')\n  }, [handleAsyncOperation])\n\n  const fetchCustomerPayments = useCallback(async (customer_id: string) => {\n    return handleAsyncOperation(() => getCustomerPayments({ baseUrl, customer_id }), 'fetch customer payments')\n  }, [handleAsyncOperation])\n\n  const createNewCustomer = useCallback(async (customer: Stripe.CustomerCreateParams) => {\n    return handleAsyncOperation(() => createCustomer({ baseUrl, customer }), 'create customer')\n  }, [handleAsyncOperation])\n\n  const updateExistingCustomer = useCallback(async (\n    customer_id: string,\n    customer: Stripe.CustomerUpdateParams\n  ) => {\n    return handleAsyncOperation(() => updateCustomer({ baseUrl, customer_id, customer }), 'update customer')\n  }, [handleAsyncOperation])\n\n  const createCheckout = useCallback(async (\n    productCart: Array<{ price_id: string; quantity: number }>,\n    customer?: { customer_id?: string; email?: string; name?: string; phone_number?: string },\n    success_url: string,\n    cancel_url: string,\n    metadata?: Record<string, string>\n  ) => {\n    return handleAsyncOperation(\n      () => checkout({ baseUrl, productCart, customer, success_url, cancel_url, metadata }),\n      'create checkout'\n    )\n  }, [handleAsyncOperation])\n\n  const clearError = useCallback(() => {\n    setError(null)\n  }, [setError])\n\n  return {\n    // State\n    loading: state.loading,\n    error: state.error,\n\n    // Actions\n    clearError,\n\n    // Product operations\n    fetchProducts,\n    fetchProduct,\n\n    // Customer operations\n    fetchCustomer,\n    fetchCustomerSubscriptions,\n    fetchCustomerPayments,\n    createNewCustomer,\n    updateExistingCustomer,\n\n    // Checkout operations\n    createCheckout,\n  }\n}\n"
    },
    {
      "target": "app/api/(stripe)/checkout/route.ts",
      "type": "template",
      "content": "import { getStripe } from \"@/lib/stripe\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\nimport type Stripe from \"stripe\";\n\nconst productCartItemSchema = z.object({\n  price_id: z.string().min(1, \"Price ID is required\"),\n  quantity: z.number().int().min(1, \"Quantity must be at least 1\"),\n});\n\nconst attachExistingCustomerSchema = z.object({\n  customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nconst newCustomerSchema = z.object({\n  email: z.string().email(\"Invalid email format\"),\n  name: z.string().min(1, \"Name is required\"),\n  phone_number: z.string().optional().nullable(),\n  create_new_customer: z.boolean().optional(),\n});\n\nconst customerSchema = z.union([attachExistingCustomerSchema, newCustomerSchema]);\n\nconst checkoutSessionSchema = z.object({\n  productCart: z.array(productCartItemSchema).min(1, \"At least one product is required\"),\n  customer: customerSchema.optional(),\n  success_url: z.string().url(\"Success URL must be a valid URL\"),\n  cancel_url: z.string().url(\"Cancel URL must be a valid URL\"),\n  metadata: z.record(z.string(), z.string()).optional(),\n});\n\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n\n    const validationResult = checkoutSessionSchema.safeParse(body);\n    if (!validationResult.success) {\n      return NextResponse.json(\n        {\n          error: \"Validation failed\",\n          details: validationResult.error.issues.map(issue => ({\n            field: issue.path.join('.'),\n            message: issue.message\n          }))\n        },\n        { status: 400 }\n      );\n    }\n\n    const { productCart, customer, success_url, cancel_url, metadata } = validationResult.data;\n\n    const stripe = getStripe();\n\n    let customerId: string | undefined;\n    if (customer && 'email' in customer) {\n      const stripeCustomer = await stripe.customers.create({\n        email: customer.email ?? \"\",\n        name: customer.name ?? \"\",\n        phone: customer.phone_number ?? \"\",\n      });\n      customerId = stripeCustomer.id;\n    } else if (customer && 'customer_id' in customer) {\n      customerId = customer.customer_id;\n    }\n\n    const sessionParams: Stripe.Checkout.SessionCreateParams = {\n      payment_method_types: [\"card\"],\n      line_items: productCart.map(item => ({\n        price: item.price_id,\n        quantity: item.quantity,\n      })),\n      mode: \"payment\",\n      success_url: success_url + \"?session_id={CHECKOUT_SESSION_ID}\",\n      cancel_url: cancel_url,\n      ...(metadata ? { metadata } : {}),\n    };\n\n    if (customerId) {\n      sessionParams.customer = customerId;\n    }\n\n    const session = await stripe.checkout.sessions.create(sessionParams);\n\n    return NextResponse.json({ url: session.url });\n  } catch (error) {\n    console.error('Stripe checkout error:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n"
    },
    {
      "target": "app/api/(stripe)/customer/route.ts",
      "type": "template",
      "content": "import { getStripe } from \"@/lib/stripe\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\nimport type Stripe from \"stripe\";\n\nconst customerCreateSchema = z.object({\n  email: z.string().email(\"Invalid email format\"),\n  name: z.string().min(1, \"Name is required\"),\n  phone_number: z.string().optional().nullable(),\n});\n\nconst customerUpdateSchema = z.object({\n  email: z.string().email(\"Invalid email format\").optional(),\n  name: z.string().min(1, \"Name is required\").optional(),\n  phone_number: z.string().optional().nullable(),\n});\n\nconst customerIdSchema = z.object({\n  customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nexport async function GET(request: Request) {\n  try {\n    const url = new URL(request.url);\n    const queryParams = {\n      customer_id: url.searchParams.get('customer_id'),\n    };\n    const validationResult = customerIdSchema.safeParse(queryParams);\n\n    if (!validationResult.success) {\n      return NextResponse.json(\n        { error: validationResult.error.issues[0].message },\n        { status: 400 }\n      );\n    }\n\n    const { customer_id } = validationResult.data;\n    const stripe = getStripe();\n    const customer = await stripe.customers.retrieve(customer_id);\n    return NextResponse.json(customer);\n  } catch (error) {\n    console.error('Error fetching customer:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n\n    const validationResult = customerCreateSchema.safeParse(body);\n    if (!validationResult.success) {\n      return NextResponse.json(\n        {\n          error: \"Validation failed\",\n          details: validationResult.error.issues.map(issue => ({\n            field: issue.path.join('.'),\n            message: issue.message\n          }))\n        },\n        { status: 400 }\n      );\n    }\n\n    const stripe = getStripe();\n    const customer = await stripe.customers.create({\n      email: validationResult.data.email,\n      name: validationResult.data.name,\n      phone: validationResult.data.phone_number ?? \"\",\n    });\n\n    return NextResponse.json(customer);\n  } catch (error) {\n    console.error('Error creating customer:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function PUT(request: Request) {\n  try {\n    const url = new URL(request.url);\n    const customer_id = url.searchParams.get('customer_id');\n    const body = await request.json();\n\n    const customerIdValidation = customerIdSchema.safeParse({ customer_id });\n    if (!customerIdValidation.success) {\n      return NextResponse.json(\n        { error: customerIdValidation.error.issues[0].message },\n        { status: 400 }\n      );\n    }\n\n    const updateValidation = customerUpdateSchema.safeParse(body);\n    if (!updateValidation.success) {\n      return NextResponse.json(\n        {\n          error: \"Validation failed\",\n          details: updateValidation.error.issues.map(issue => ({\n            field: issue.path.join('.'),\n            message: issue.message\n          }))\n        },\n        { status: 400 }\n      );\n    }\n\n    const { customer_id: validCustomerId } = customerIdValidation.data;\n    const stripe = getStripe();\n    \n    const updateData: Stripe.CustomerUpdateParams = {};\n    if (updateValidation.data.email) updateData.email = updateValidation.data.email;\n    if (updateValidation.data.name) updateData.name = updateValidation.data.name;\n    if (updateValidation.data.phone_number) updateData.phone = updateValidation.data.phone_number;\n\n    const customer = await stripe.customers.update(validCustomerId, updateData);\n    return NextResponse.json(customer);\n  } catch (error) {\n    console.error('Error updating customer:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n"
    },
    {
      "target": "app/api/(stripe)/customer/payments/route.ts",
      "type": "template",
      "content": "import { getStripe } from \"@/lib/stripe\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\nconst paymentQuerySchema = z.object({\n  customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nexport async function GET(request: Request) {\n  try {\n    const url = new URL(request.url);\n    const customer_id = url.searchParams.get('customer_id');\n\n    const validationResult = paymentQuerySchema.safeParse({ customer_id });\n\n    if (!validationResult.success) {\n      return NextResponse.json(\n        { error: validationResult.error.issues[0].message },\n        { status: 400 }\n      );\n    }\n\n    const validatedParams = validationResult.data;\n    const stripe = getStripe();\n\n    const paymentIntents = await stripe.paymentIntents.list({\n      customer: validatedParams.customer_id,\n      limit: 100,\n    });\n\n    return NextResponse.json(paymentIntents.data);\n  } catch (error) {\n    console.error('Error fetching customer payments:', error);\n    return NextResponse.json({ error: 'Failed to fetch customer payments' }, { status: 500 });\n  }\n}\n"
    },
    {
      "target": "app/api/(stripe)/customer/subscriptions/route.ts",
      "type": "template",
      "content": "import { getStripe } from \"@/lib/stripe\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\nconst subscriptionQuerySchema = z.object({\n  customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nexport async function GET(request: Request) {\n  try {\n    const url = new URL(request.url);\n    const customer_id = url.searchParams.get('customer_id');\n\n    const validationResult = subscriptionQuerySchema.safeParse({ customer_id });\n\n    if (!validationResult.success) {\n      return NextResponse.json(\n        { error: validationResult.error.issues[0].message },\n        { status: 400 }\n      );\n    }\n\n    const stripe = getStripe();\n    const subscriptions = await stripe.subscriptions.list({\n      customer: validationResult.data.customer_id,\n      limit: 100,\n    });\n\n    return NextResponse.json(subscriptions.data);\n  } catch (error) {\n    console.error('Error fetching customer subscriptions:', error);\n    return NextResponse.json({ error: 'Failed to fetch customer subscriptions' }, { status: 500 });\n  }\n}\n"
    },
    {
      "target": "app/api/(stripe)/product/route.ts",
      "type": "template",
      "content": "import { getStripe } from \"@/lib/stripe\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\nconst productIdSchema = z.object({\n  product_id: z.string().min(1, \"Product ID is required\"),\n});\n\nexport async function GET(request: Request) {\n  try {\n    const url = new URL(request.url);\n    const queryParams = {\n      product_id: url.searchParams.get('product_id'),\n    };\n    const validationResult = productIdSchema.safeParse(queryParams);\n\n    if (!validationResult.success) {\n      return NextResponse.json(\n        { error: validationResult.error.issues[0].message },\n        { status: 400 }\n      );\n    }\n\n    const { product_id } = validationResult.data;\n    const stripe = getStripe();\n\n    const product = await stripe.products.retrieve(product_id);\n    return NextResponse.json(product);\n  } catch (error) {\n    console.error('Error retrieving product:', error);\n    return NextResponse.json(\n      { error: 'Failed to retrieve product' },\n      { status: 500 }\n    );\n  }\n}\n"
    },
    {
      "target": "app/api/(stripe)/products/route.ts",
      "type": "template",
      "content": "import { getStripe } from \"@/lib/stripe\";\nimport { NextResponse } from \"next/server\";\n\nexport async function GET() {\n  try {\n    const stripe = getStripe();\n    const products = await stripe.products.list({ limit: 100 });\n    return NextResponse.json(products.data);\n  } catch (error) {\n    console.error('Error fetching products:', error);\n    return NextResponse.json(\n      { error: \"Failed to fetch products\" },\n      { status: 500 }\n    );\n  }\n}\n"
    },
    {
      "target": "app/api/(stripe)/webhook/route.ts",
      "type": "template",
      "content": "import { headers } from \"next/headers\";\nimport { getStripe } from \"@/lib/stripe\";\nimport type Stripe from \"stripe\";\n\nexport async function POST(request: Request) {\n  const headersList = await headers();\n  const stripe = getStripe();\n  \n  try {\n    const body = await request.text();\n    const sig = headersList.get(\"stripe-signature\");\n\n    if (!sig) {\n      return NextResponse.json(\n        { error: 'Missing Stripe signature' },\n        { status: 400 }\n      );\n    }\n\n    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET!;\n    let event: Stripe.Event;\n\n    try {\n      event = stripe.webhooks.constructEvent(body, sig, webhookSecret);\n    } catch (err) {\n      console.error('Webhook signature verification failed:', err);\n      return NextResponse.json(\n        { error: 'Webhook verification failed' },\n        { status: 400 }\n      );\n    }\n\n    try {\n      switch (event.type) {\n        case 'customer.subscription.created':\n        case 'customer.subscription.updated':\n        case 'customer.subscription.deleted': {\n          const subscription = event.data.object as Stripe.Subscription;\n          console.log('Subscription event:', event.type, subscription.id);\n          break;\n        }\n\n        case 'payment_intent.succeeded': {\n          const paymentIntent = event.data.object as Stripe.PaymentIntent;\n          console.log('Payment succeeded:', paymentIntent.id, paymentIntent.amount);\n          break;\n        }\n\n        case 'payment_intent.payment_failed': {\n          const paymentIntent = event.data.object as Stripe.PaymentIntent;\n          console.log('Payment failed:', paymentIntent.id, paymentIntent.last_payment_error);\n          break;\n        }\n\n        case 'charge.refunded': {\n          const charge = event.data.object as Stripe.Charge;\n          console.log('Charge refunded:', charge.id, charge.amount_refunded);\n          break;\n        }\n\n        default:\n          console.log('Unhandled event type:', event.type);\n          break;\n      }\n\n      return NextResponse.json(\n        { message: \"Webhook processed successfully\" },\n        { status: 200 }\n      );\n    } catch (err) {\n      console.error('Error handling webhook event:', err);\n      return NextResponse.json(\n        { error: 'Internal server error' },\n        { status: 500 }\n      );\n    }\n  } catch (error) {\n    console.log(\" ----- webhook verification failed -----\");\n    console.log(error);\n    return NextResponse.json(\n      { message: \"Webhook verification failed\" },\n      { status: 400 }\n    );\n  }\n}\n"
    },
    {
      "target": ".env.example",
      "type": "template",
      "content": "STRIPE_SECRET_KEY=sk_test_12345...\nSTRIPE_WEBHOOK_SECRET=whsec_12345...\nNEXT_PUBLIC_APP_URL=http://localhost:3000"
    }
  ],
  "dependencies": ["stripe", "zod"]
}
